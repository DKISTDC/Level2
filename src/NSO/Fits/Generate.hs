{-# LANGUAGE UndecidableInstances #-}

module NSO.Fits.Generate where

import App.Effect.Scratch as Scratch
import Data.ByteString qualified as BS
import Data.List qualified as L
import Data.Massiv.Array ()
import Data.Text qualified as T
import Effectful
import Effectful.Dispatch.Dynamic
import Effectful.Error.Static
import Effectful.GenRandom
import Effectful.Log
import Effectful.Writer.Static.Local
import NSO.Fits.Generate.Error
import NSO.Fits.Generate.Headers
import NSO.Fits.Generate.Headers.Keywords (HeaderKeywords (..))
import NSO.Fits.Generate.Headers.LiftL1 (LiftL1Error (..))
import NSO.Fits.Generate.Headers.Types (DateTime (..), Depth, Key (..), SlitX)
import NSO.Fits.Generate.Profile
import NSO.Fits.Generate.Quantities (Quantities (..), decodeQuantitiesFrames, quantitiesHDUs)
import NSO.Prelude
import NSO.Types.Common
import NSO.Types.InstrumentProgram (Proposal)
import NSO.Types.Inversion (Inversion)
import Telescope.Fits as Fits
import Telescope.Fits.Encoding (replaceKeywordLine)


readQuantitiesFrames :: (Scratch :> es) => Path InvResults -> Eff es [Quantities [SlitX, Depth]]
readQuantitiesFrames p = do
  inp <- send $ Scratch.ReadFile p
  decodeQuantitiesFrames inp


readOrigProfileFrames :: (Scratch :> es) => Path OrigProfile -> Eff es (ProfileFrames Original)
readOrigProfileFrames p = do
  inp <- send $ Scratch.ReadFile p
  decodeProfileFrames @Original inp


readFitProfileFrames :: (Scratch :> es) => Path InvProfile -> Eff es (ProfileFrames Fit)
readFitProfileFrames p = do
  inp <- send $ Scratch.ReadFile p
  decodeProfileFrames @Fit inp


data GenerateFrame = GenerateFrame
  { quantities :: Quantities [SlitX, Depth]
  , profileFit :: ProfileFrame Fit
  , profileOrig :: ProfileFrame Original
  , l1Frame :: BinTableHDU
  }


collateFrames :: (Error GenerateError :> es) => [Quantities [SlitX, Depth]] -> [ProfileFrame Fit] -> [ProfileFrame Original] -> [BinTableHDU] -> Eff es [GenerateFrame]
collateFrames qs pfs pos ts
  | allFramesEqual = pure $ L.zipWith4 GenerateFrame qs pfs pos ts
  | otherwise = throwError mismatchError
 where
  allFramesEqual :: Bool
  allFramesEqual =
    all (== length qs) frameSizes

  frameSizes :: [Int]
  frameSizes = [length qs, length pfs, length pos, length ts]

  mismatchError :: GenerateError
  mismatchError = MismatchedFrames frameSizes


writeL2Frame :: (Log :> es, Scratch :> es) => Id Proposal -> Id Inversion -> Fits -> DateTime -> Eff es ()
writeL2Frame ip ii f (DateTime dt) = do
  let dir = outputL2 ip ii
  let path = filePath dir filenameL2
  send $ Scratch.WriteFile path $ encodeL2 f
 where
  filenameL2 :: Path' Filename L2Frame
  filenameL2 = Path $ cs (T.toUpper $ T.map toUnderscore $ ii.fromId <> "_" <> dt) <> "_L2.fits"

  toUnderscore :: Char -> Char
  toUnderscore '.' = '_'
  toUnderscore ':' = '_'
  toUnderscore '-' = '_'
  toUnderscore c = c

  -- \| Encode and insert framevol
  encodeL2 :: Fits -> BS.ByteString
  encodeL2 f' =
    let out = Fits.encode f'
        mb = fromIntegral (BS.length out) / 1000000
     in replaceKeywordLine "FRAMEVOL" (Float mb) (Just "[Mb]") out


generateL2Fits
  :: (Error GenerateError :> es, GenRandom :> es)
  => UTCTime
  -> Id Inversion
  -> WavProfiles Original
  -> WavProfiles Fit
  -> GenerateFrame
  -> Eff es (Fits, DateTime)
generateL2Fits now i wpo wpf gf =
  runErrorNoCallStackWith @LiftL1Error (throwError . LiftL1) $ do
    (prim, dateBeg) <- primaryHDU i gf.l1Frame
    imgs <- quantitiesHDUs now gf.l1Frame.header gf.quantities
    profs <- profileHDUs now gf.l1Frame.header wpo wpf gf.profileOrig gf.profileFit
    let fits = Fits prim $ fmap Image $ imgs <> profs
    pure (fits, dateBeg)


-- What is supposed to go in here?
primaryHDU :: (Error LiftL1Error :> es, GenRandom :> es) => Id Inversion -> BinTableHDU -> Eff es (PrimaryHDU, DateTime)
primaryHDU di l1 = do
  (dateBeg, hs) <- runWriter allKeys
  let hdu = PrimaryHDU (Header hs) emptyDataArray
  pure (hdu, dateBeg)
 where
  allKeys = do
    dateBeg <- primKeys
    teleKeys
    datacenterKeys
    dkistKeys
    adaptiveKeys
    pure dateBeg

  primKeys = do
    ob <- observationHeader l1.header
    sectionHeader "Observation" "Keys describing the observation and general metadata"
    addKeywords $ headerKeywords @ObservationHeader ob
    pure ob.dateBeg.ktype

  teleKeys = do
    th <- telescopeHeader l1.header
    sectionHeader "Telescope" "Keys describing the pointing and op of the Telescope"
    addKeywords $ headerKeywords @TelescopeHeader th

  datacenterKeys = do
    dc <- datacenterHeader l1.header di
    cep <- contribExpProp l1.header
    sectionHeader "Datacenter" "Keys generated by the DKIST data center to describe processing performed, archiving or extra metadata"
    addKeywords $ headerKeywords @Datacenter dc
    addKeywords $ headerKeywords @ContribExpProp cep

  dkistKeys = do
    dk <- dkistHeader l1.header
    sectionHeader "DKIST Operations" "Information about this configuration or operations of the facility when generating this data"
    addKeywords $ headerKeywords @DKISTHeader dk

  adaptiveKeys = do
    ao <- adaptiveOpticsHeader l1.header
    sectionHeader "Adaptive Optics" "Keys describing aspects of the adaptive optics system"
    addKeywords $ headerKeywords @AdaptiveOptics ao

-- runGenTestIO :: Eff '[GenRandom, Error LiftL1Error, IOE] a -> IO a
-- runGenTestIO eff = do
--   res <- runEff $ runErrorNoCallStack $ runGenRandom eff
--   case res of
--     Left e -> throwM e
--     Right a -> pure a
