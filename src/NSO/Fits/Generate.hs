{-# LANGUAGE UndecidableInstances #-}

module NSO.Fits.Generate
  ( generateL2Fits
  , L2Frame (..)
  , collateFrames
  , decodeQuantitiesFrames
  , decodeProfileFrames
  , filenameL2
  , encodeL2
  ) where

import Data.ByteString qualified as BS
import Data.List qualified as L
import Data.Massiv.Array ()
import Data.Text qualified as T
import Effectful
import Effectful.Error.Static
import Effectful.GenRandom
import Effectful.Writer.Static.Local
import NSO.Fits.Generate.Error
import NSO.Fits.Generate.Headers
import NSO.Fits.Generate.Headers.Keywords (HeaderKeywords (..))
import NSO.Fits.Generate.Headers.LiftL1 (LiftL1Error (..))
import NSO.Fits.Generate.Headers.Types (DateTime (..), Depth, Key (..), SlitX)
import NSO.Fits.Generate.Profile
import NSO.Fits.Generate.Quantities (Quantities (..), decodeQuantitiesFrames, quantitiesHDUs)
import NSO.Prelude
import NSO.Types.Common
import NSO.Types.Inversion (Inversion)
import Telescope.Fits as Fits
import Telescope.Fits.Encoding (replaceKeywordLine)


data L2Frame = L2Frame
  { quantities :: Quantities [SlitX, Depth]
  , profileFit :: ProfileFrame Fit
  , profileOrig :: ProfileFrame Original
  , l1Frame :: BinTableHDU
  }


collateFrames :: (Error GenerateError :> es) => [Quantities [SlitX, Depth]] -> [ProfileFrame Fit] -> [ProfileFrame Original] -> [BinTableHDU] -> Eff es [L2Frame]
collateFrames qs pfs pos ts
  | allFramesEqual = pure $ L.zipWith4 L2Frame qs pfs pos ts
  | otherwise = throwError mismatchError
 where
  allFramesEqual :: Bool
  allFramesEqual =
    all (== length qs) frameSizes

  frameSizes :: [Int]
  frameSizes = [length qs, length pfs, length pos, length ts]

  mismatchError :: GenerateError
  mismatchError = MismatchedFrames frameSizes


filenameL2 :: Id Inversion -> DateTime -> Path' Filename L2Frame
filenameL2 ii (DateTime dt) = Path $ cs (T.toUpper $ T.map toUnderscore $ ii.fromId <> "_" <> dt) <> "_L2.fits"
 where
  toUnderscore :: Char -> Char
  toUnderscore '.' = '_'
  toUnderscore ':' = '_'
  toUnderscore '-' = '_'
  toUnderscore c = c


-- \| Encode and insert framevol
encodeL2 :: Fits -> BS.ByteString
encodeL2 f' =
  let out = Fits.encode f'
      mb = fromIntegral (BS.length out) / 1000000
   in replaceKeywordLine "FRAMEVOL" (Float mb) (Just "[Mb]") out


generateL2Fits
  :: (Error GenerateError :> es, GenRandom :> es)
  => UTCTime
  -> Id Inversion
  -> WavProfiles Original
  -> WavProfiles Fit
  -> L2Frame
  -> Eff es (Fits, DateTime)
generateL2Fits now i wpo wpf gf =
  runErrorNoCallStackWith @LiftL1Error (throwError . LiftL1) $ do
    (prim, dateBeg) <- primaryHDU i gf.l1Frame
    imgs <- quantitiesHDUs _ now gf.l1Frame.header gf.quantities
    profs <- profileHDUs _ now gf.l1Frame.header wpo wpf gf.profileOrig gf.profileFit
    let fits = Fits prim $ fmap Image $ imgs <> profs
    pure (fits, dateBeg)


-- What is supposed to go in here?
primaryHDU :: (Error LiftL1Error :> es, GenRandom :> es) => Id Inversion -> BinTableHDU -> Eff es (PrimaryHDU, DateTime)
primaryHDU di l1 = do
  (dateBeg, hs) <- runWriter allKeys
  let hdu = PrimaryHDU (Header hs) emptyDataArray
  pure (hdu, dateBeg)
 where
  allKeys = do
    dateBeg <- primKeys
    teleKeys
    datacenterKeys
    dkistKeys
    adaptiveKeys
    pure dateBeg

  primKeys = do
    ob <- observationHeader l1.header
    sectionHeader "Observation" "Keys describing the observation and general metadata"
    addKeywords $ headerKeywords @ObservationHeader ob
    pure ob.dateBeg.ktype

  teleKeys = do
    th <- telescopeHeader l1.header
    sectionHeader "Telescope" "Keys describing the pointing and op of the Telescope"
    addKeywords $ headerKeywords @TelescopeHeader th

  datacenterKeys = do
    dc <- datacenterHeader l1.header di
    cep <- contribExpProp l1.header
    sectionHeader "Datacenter" "Keys generated by the DKIST data center to describe processing performed, archiving or extra metadata"
    addKeywords $ headerKeywords @Datacenter dc
    addKeywords $ headerKeywords @ContribExpProp cep

  dkistKeys = do
    dk <- dkistHeader l1.header
    sectionHeader "DKIST Operations" "Information about this configuration or operations of the facility when generating this data"
    addKeywords $ headerKeywords @DKISTHeader dk

  adaptiveKeys = do
    ao <- adaptiveOpticsHeader l1.header
    sectionHeader "Adaptive Optics" "Keys describing aspects of the adaptive optics system"
    addKeywords $ headerKeywords @AdaptiveOptics ao

-- runGenTestIO :: Eff '[GenRandom, Error LiftL1Error, IOE] a -> IO a
-- runGenTestIO eff = do
--   res <- runEff $ runErrorNoCallStack $ runGenRandom eff
--   case res of
--     Left e -> throwM e
--     Right a -> pure a
